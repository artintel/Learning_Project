# 使用场景

![image-20201127150850355](C:\Users\HS\AppData\Roaming\Typora\typora-user-images\image-20201127150850355.png)

多个客户端同时给服务器发消息，那么就需要开线程进行处理才能做到同时？

但是不能说有十万个客户端就要开十万个线程。

# 所以引入线程池的概念：

1. 避免线程太多，使得内存耗尽
2. 避免创建与销毁线程的代价
3. 任务与执行分离



# 线程池组件

1. 任务队列
2. 执行队列
3. 管理组件 ---> 锁



pthread_cond_t  线程条件变量

## 线程池的任务添加与销毁



callback != task

## 回调函数：

本来回调与线程之间没多大关系，只是线程是采用回调的方式来执行你的代码，这个是它们之间存在的一点联系。

回调函数：
一般用于模块解耦，提供功能扩展用。
要清楚的认识回调函数，需要分清这两者，调用方（即接口声明方）、（即被调用方）实现方。
事实上回调函数无处不再，控制台中的main、WIN32中的WinMain、WINDRV中的DriverEntry都是回调函数，所以你会发现回调函数的原型都是固定的（当然main的标准原型可以有好几种，不在此讨论），但其函数体均由你自己来实现，然后在适当的时机被调调用方用（对于刚才所说的那几种情况则是由crt、crt、system进程在程序初始化时进行调用，对于驱动程序框架则完全是回调机制）。

线程：
概念不用说了，这里只说过程。你需要实现一个函数体（函数原型是实现规定好的），然后调用线程开启函数向系统传递一个函数指针开启一个线程。然后由系统通过刚才传递进来的函数指针再来调用，所以就实现了你的线程过程。

实现机理：
（回调）调用方提供一个注册接口给（回调）实现方，并通常会提供一个回调上下文让你绑定一个任意型数据进去（通常是平台字节数大小，32位则是4字节，当然这个是通常，实际提供与否看人家心情了）。



## 线程的唤醒和等待

phtread_cond_wait() 理解：

```C++
struct xxx* head; /** 全局线程共享变量*/
pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; /** 为条件变量搭配的互斥锁*/
pthread_cond_t cond = PTHREAD_COND_INITIALIZER; /** 定义全局线程共享的条件变量*/
  
staticvoid* thread_func(void*arg)
{
/** 首先先获得互斥锁，表示同一时间只能有一个线程等待条件变量
 * 如果没有保持只有一个线程监听条件变量的话，那有可能会引起线程的"惊群"现象
 */
pthread_mutex_lock(&mtx);
  
/** 下面理解为什么需要先判断 head == NULL 的值(假设这里就是需要等待 head == NULL )
 * 根据pthread相关文档理解: 假设线程1执行到pthread_cond_wait()时，首先线程释放mtx互斥锁，
 * 之后再开始等待pthread_cond_signal()或者pthread_cond_broadcast()发送过来的"条件满足信号"
 * 假如这时候某另外的一个线程2获得了mtx锁并改变head的值,使得head == NULL 并发送了信号且
 * 完成之后释放了mtx锁, 这时候可能系统存在线程3正在等待获得互斥锁，那么现在有两种情况:1.线程3
 * 获得锁，之后对head进行了一些操作，之后可能发送了信号，再释放了互斥锁;2.线程1获得了互斥
 * 锁mtx，那么这时候线程1继续原来等待的逻辑,由于等待时释放了锁，现在需要重新获得这种情况也获得了,
 * 这时候程序执行while(head == NULL)的判断，ok, 现在能明白为什么这里需要判断 head == NULL ?了，因为在
 * 上面情况1中线程3比线程1可能更早一步获得锁之后对head操作并使得head != NULL ,事实上大型的系统可能会有更多
 * 的线程同时在竞争一个互斥锁，对于共享变量值的改变可能会有更多的情况，也就是说线程1进入等待之后释放锁，
 * 直到收到唤醒信号, 在去重新获得锁的过程中，不一定能在收到信号后作为第一个获得锁的线程，也就是在获得锁时
 * 其他线程可能获得锁并改变了head的值，比如上面例子尽管线程2在head == NULL 时发出了信号。
 * 线程1判断head == NULL是否满足，如果不满足条件，则重新释放mtx锁，并进入信号等待的过程，重复上面唤醒的逻辑
 * 直到 head == NULL 时，程序执行之后的逻辑，最后释放mtx互斥锁
 */
while(head != NULL)
{
pthread_cond_wait(&cond, &mtx);
}
  
/** head == NULL 时执行的逻辑*/
...
  
pthread_mutex_unlock(&mtx);//临界区数据操作完毕，释放互斥锁
  
return0;C++
}
```

pthread_cond_broadcast() 唤醒所有的等待线程

pthread_cond_signal() 唤醒一个线程





# gdb 调试过程遇到的问题

1. 常规使用

   > gcc -o thread thread.c -lpthread -g
   >
   > gdb ./thread
   >
   > b --- 添加断点
   >
   > r --- 运行
   >
   > c --- continue

2. pool --> memset()

3. void* arg 问题，导致了指针偏移

4. 主线程没有等待任务的结束。子线程被强制结束出现了段错误 可以通过 getchar() 等待一下
